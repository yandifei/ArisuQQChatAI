# <center>爱丽丝QQ聊天AI</center>

[TOC]

由于GUI是主进程，这就导致了我没有办法实现按一个按钮就能创建进程池并分派任务直接使用

## 开发守则
### 权限系统
- **因为此项目并不是最好的Bot（它的上限确实摆在那里，所以设置“完美”的权限系统确实没有任何意义。）**

1. 对于退出指令即使是超管也必须要密码（别人可以通过修改和你相同的备注名获得和你等同的权限）。

2. 可以在初始化时把`移除危险指令`的选项打开，仅加载限制指令。
   1. 相比于之前的指令系统，这部分指令是独立加载的，之前是全部加载后通过检查指令是否在危险指令列表实现的，也就是每次使用指令的时候都要检查是否开启了移除危险指令限制和去危险指令列表里面查找是否为危险指令。
   2. 事实上，`危险指令`也是它功能多样性的体现，移除确实少了非常实用的特性(如`人设切换`)。

#### 权限分级
- 这里将对以往的指令做出更改：`#开启权限隔离`改为`#开启指令权限限制`、`#关闭权限隔离`改为`#关闭指令权限限制`

**超级管理员（root）：** 只能有一个，自己(自己在群里的非机器人账号)或机器人账号
权限功能：（简单了当就是可以使用所有指令，下面列举的不用看了，作者自己看的。）
1. 拥有使用`#退出`指令的权限(退出指令还需要密码)。
2. 拥有`#开启指令权限限制`和`#关闭指令权限限制`的功能。
3. 其他指令功能

</br>

**管理员(administrators)：** Q群的群主和Q群的管理员，之前的应该有个bug：检测不到管理员或群主无法录入就崩溃，在这里将进行重写修复。
权限功能：（除了退出指令以外的所有指令）
1. 拥有`#开启指令权限限制`和`#关闭指令权限限制`的指令。
2. 除了`#退出`的其他指令

**其他人(other)**：普通群友
权限功能：（除了退出指令和权限隔离指令以外的所有指令）
1. 基础对话。
2. 无限制指令的调用

### 指令系统
- 为了方便上手，这里先划分为无限制指令和限制指令
重写指令系统吧，确实看着难看和糟心，可以用上信号和槽的编程思路。
1. 之前`#评分`是默认50，现在必须附带参数
2. `#输出格式`有bug，切换之后无法且换回来了
   1. 原本的格式
        ```python
        if response_format == "text" or response_format == "json":
        self.response_format = {response_format}
        if out: print(f"已指定模型必须输出的格式为{response_format}")
        return True
        if out: print(f"\033[91m参数有误，指定模型必须输出的格式为\"text\"或\"json\"，不对该参数进行任何修改\033[0m")
        return False
        ```
    2. 修复传入格式和构造错误
        ```python
            if response_format == "text" or response_format == "json_object":
        self.response_format = {"type": response_format}
        if out: print(f"已指定模型必须输出的格式为{response_format}")
        return True
        if out: print(f"\033[91m参数有误，指定模型必须输出的格式为\"text\"或\"json_object\"，不对该参数进行任何修改\033[0m")
        return False
        ```

#### 所有指令
1. 帮助之类的指令
    #帮助
    #指令查询
2. 权限管理指令
    #超管
    #所有管理员
    #开启指令权限限制
    #关闭指令权限限制
3. 额外指令
    #jm（下载禁漫的指令）
4. 特殊指令
    #兼容
    #测试接口
    #初始化
5. 对话参数调节指令
    #模型切换
    #V3模型
    #R1模型
    #评分
    #最大token数
    #输出格式
    #敏感词
    #删除敏感词
    #流式
    #非流式
    #开启请求统计
    #关闭请求统计
    #温度
    #核采样
    #工具列表
    #工具开关
    #开启对数概率输出
    #关闭对数概率输出
    #位置输出概率
6. FIM对话参数指令
    #FIM对话
    #FIM补全开头
    #FIM完整输出
    #FIM对数概率输出
    #FIM补全后缀
7. 上下文参数
    #思维链
    #对话轮次
    #聊天记录
    #清空对话历史
8. 多人设管理指令
    #人设切换
    #所有人设
    #人设查询
    #当前人设
    #人设自定
    #删除人设
9.  场景关键词自动调控参数指令
    #代码
    #数学
    #数据
    #分析
    #对话
    #翻译
    #创作
    #写作
    #作诗
10. 余额和token数查询
    #余额
    #token

#### 无限制指令和限制指令
##### 无限制指令
*帮助之类的指令*
1. #帮助
2. #指令查询

*对话参数调节指令*
1. #模型切换
2. #V3模型
3. #R1模型
4. #评分
5. #非流式

*FIM对话参数*
4. #FIM对数概率输出
1. #FIM对话
2. #FIM补全开头
3. #FIM完整输出
4. #FIM补全后缀

*上下文参数*
1. #思维链
2. #清空对话历史

*场景关键词自动调控参数*
1. #代码
2. #数学
3. #数据
4. #分析
5. #对话
6. #翻译
7. #创作
8. #写作
9. #作诗

*余额和token数查询*
1. #余额
2. #token
##### 限制指令
*权限管理指令*
1. #超管
2. #所有管理员
3. #开启指令权限限制
4. #关闭指令权限限制

*额外指令*
1. #jm

*特殊指令*
1. #兼容
2. #测试接口
3. #初始化

1. #开启请求统计
2. #关闭请求统计
3. #温度
4. #核采样
5. #工具列表
6. #工具开关
7. #开启对数概率输出
8. #关闭对数概率输出
9. #位置输出概率

*FIM对话参数*
1. #FIM对数概率输出

*上下文参数*
1. #对话轮次
2. #聊天记录

*人设指令*
1. #人设切换
2. #所有人设
3. #人设查询
4. #当前人设
5. #人设自定
6. #删除人设
#### 指令执行逻辑
1. 调用`split_respond_msg`解析截获的文本，简单处理之后拿到最核心的消息(msg:去掉@、人名、时间)。
2. 判断核心消息是否为空(简单处理后可以消息为空，比如仅仅@你)->判断消息的第一个字符是否为`#`->判断消息是否大于2个字符(`#`后面可能什么都没有)
3. 把核心消息(`#文本`)放到指令映射里面进行查找，检查是否存在该指令。某些指令需要特定的参数，所以在执行指令的时候会用异常捕获告诉调用者缺少参数
4. 根据字典进行判断函数是否执行成功，执行成功拿得到`bool`类型的返回值
5. 根据返回值拿到执行成功发送的消息或执行失败发送的消息，需要特别*注意*的是*执行成功/失败发送的消息*这个消息本身可能就是一个方法或函数(极有可能为匿名函数)
6. 如果返回消息是一个方法或函数(极有可能为匿名函数)则执行这个方法或函数拿到返回值直接发送。

### 重写用户配置系统
#### 原来的配置文件
配置文件名：`UserSettings.ini`
[说明文档] [软件声明]、[说明文档]、[项目信息] 内容。
#### 新的配置文件
- 使用分类对配置文件进行管理也方便用户和开发者进行修改
1. 绑定配置：`Bind.ini`
2. 全局热键配置：`Hotkey.ini`
3. 用户配置：`UserSettings.ini`

##### 绑定配置：`Bind.ini`
放置群聊绑定的信息，因为中控不止一个Q群，所有可以是多个。
```ini
[qq_group_name]         # QQ群名
# 填机器人在群里的名（优先群里面机器人账号的备注名）
bot_name = 机器人名
# 最高权限者，只能有一个
root = 最高权限者
# 退出指令的密码
exit_password = 退出指令的密码  
# 初始人设
init_role = 爱丽丝
# Q群窗口的位置
qq_group_location = 0,0
# 移除危险的指令
remove_dangerous_order = False
```
##### 全局热键配置：`Hotkey.ini`
放置全局热键(不是快捷键)，即使程序没有焦点在后台也能用。
```ini
[运行和停止]
# 运行程序监听回复
running = F10
# 停止程序监听回复
stop = F12

[动态主页]
# 开启主页动态壁纸（为了看女儿）
running = F7
# 关闭主页动态壁纸（减少资源损耗）
stop = F8
```

##### 用户配置：`UserSettings.ini`
放置软件本体的用户设置（不包括热键和Q群绑定信息）
```ini
[初始界面]
# 初始界面的窗口下标
init_index = 1

[用户界面位置]      # 保存用户设置的界面位置
主页 = 0
状态监测 = 1
热键 = 2
问题链接 = 3
用户设置 = 4

[原始界面位置]      # 放置最开始界面位置
主页 = 0
状态监测 = 1
热键 = 2
问题链接 = 3
用户设置 = 4
```

### 密钥接收和安全处理
#### 之前的方案：
- 延续OpenAI和开发手册的建议，将API密钥放入环境变量中
- 测试密钥有效性
- 手动将密钥注入用户环境变量

1. 用户设置界面有提供密钥输入的控件
2. 检测密钥是否有效(部分关键代码，请求头我都懒得写了)
```python
    response = requests.get(
                "https://api.deepseek.com/user/balance",  # 请求网址
                headers={"Authorization": f"Bearer {self.APIKeyInput.text()}"},  # 请求头(从文本控件里面拿到key)
                timeout = 5  # 添加超时设置，防止卡死
            )
    if response.status_code != 200:  # 检查响应状态码
        print("API密钥无效或未授权，检查密钥是否正确或重启python进程")
    else:
        print("API密钥有效，把密钥注入用户环境变量")
```
3. 手动将密钥注入用户环境变量中

##### 不考虑`dotenv`原因
`from dotenv import load_dotenv`确实能实现系统变量的效果。
1. 我git push后就会直接把我的密钥暴露出去(.gitignore可以解决)
2. 如果直接把整个软件压缩打包给别人，那别人就可以直接使用这个密钥了
3. 考虑到自己是生产环境以及打包分发的问题就没考虑这个库了。

#### 现在的方案
- 零文件存储：把密钥交给由操作系统托管（Windows Credential Manager/macOS Keychain/Linux Secret Service）
- 自动加密：系统级AES加密保护存储内容
- 用户隔离：不同操作系统用户无法互相访问密钥

相比之前：
1. 不用担心`git push`会把密钥暴漏
2. 确实做到了生产环境的隔离和不用担忧用户自己打包分发会泄露
3. 避免某些系统进程读取环境变量并把明文的密钥记录到日志中直接暴漏
4. 缺点：需要通过指令代码去删除这个密钥

当需要更新密钥时，直接覆盖 `keyring.set_password("DEEPSEEK_API_KEY", "爱丽丝", "密钥")` 。不需要进行删除后再添加，因为这是原子操作减少一次系统调用

#### 密钥查看
1. 打开 控制面板-> 用户账户 > 凭证管理器
2. 选择 Windows凭据
3. 查找"普通凭据"中的 DEEPSEEK_API_KEY/爱丽丝
4. 点击显示密码（如果电脑设置密码需要输入电脑的秘密才能查看）


### QQ自动回复重写
自动回复项目延用:https://github.com/yandifei/DeepseekConversationEngine/tree/main/%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B/QQ%E6%9C%BA%E5%99%A8%E4%BA%BA

根本核心：QQMessageMonitor这个类

这回把核心给提炼出来并做优化
增加jm的功能

考虑到该程序主要是CPU计算，所以进程池就不能填满，填满还有可能引起资源争抢导致性能下降.(逻辑核心数)

根据电脑状况来分配逻辑核心数资源，默认是通过计算来获取核心数并进行合理分配

如果无法获取核心数则默认为4核心数，用户也可以自行修改。考虑到是在win平台以及现在CPU都有超线程计算这里就是使用以下计算
```python
if psutil.cpu_count(False) and psutil.cpu_count(True):   # 能获取到CPU核心数才执行最佳计算
    physical_cores = psutil.cpu_count(False)                # 物理核心数
    logical_cores = psutil.cpu_count(True)                  # 逻辑核心数
    use_cores = min(int(physical_cores * 1.5), logical_cores)   # 使用核心数
# 输入可使用的逻辑核心数，默认通过编程计算。物理核心数乘上1.5后去掉小数点，如过这个值超过最大逻辑核心数就使用最大逻辑核心数。
```

相比之前，重开后对于`ask`失败会有直接的返回值，如果`aks`中出现了问题，比如密钥失效等中途出现的问题也能直接发送出来到QQ里面，之前是只会显示在控制台上的。并且会把这次的失败记录给AI，确保AI知道刚才请求出现了错误。
```python
try:
    pass    # 具体的过程
    # 把这次错误添加AI的回答历史（包括流式和非流式的）
 except OpenAIError as Error:
    if status_code == 400:
        assistant_content =  "请求体格式错误，请根据错误信息提示修改请求体"
    else:
        pass
        #...省略错误判断过程
    assistant_content = "此次请求过程中发生严重错误:" + assistant_content   # 核心代码
    self.dialog_history.append({"role": "assistant", "content": assistant_content})
    return assistant_content  # 调用失败返回失败信息
```

`SendKeys`的方法有漏洞，不设置参数`charMode=True `它不能直接进行纯文本输出，不然就会出问题，可以转发文本的时候出现被注入的情况。
**再次经过多次实践**最终发现QQ确实只拦截cv来完成粘贴文本

良好方案1
```python
"""当前最好的方案（能检测光标（焦点是否在QQ窗口上而不是其他窗口上，其他窗口会出出现异常））
# 激活窗口到前台
win32gui.SetForegroundWindow(self.hwnd)
# 先发送 WM_ACTIVATE 激活窗口再发送 WA_CLICKACTIVE 鼠标激活
# win32api.SendMessage(self.hwnd, win32con.WM_ACTIVATE, win32con.WA_CLICKACTIVE,0)
# 等待激活
sleep(0.1)
self.edit_box.SendKeys(text, 0, 0.01,charMode=False)
"""
```
方案2
```python
"""后台模拟Ctrl+V按键"""
win32api.keybd_event(win32con.VK_CONTROL, 0, 0, 0)                  # 按下Ctrl
win32api.keybd_event(ord('V'), 0, 0, 0)                             # 按下V
win32api.keybd_event(ord('V'), 0, win32con.KEYEVENTF_KEYUP, 0)              # 释放V
win32api.keybd_event(win32con.VK_CONTROL, 0, win32con.KEYEVENTF_KEYUP, 0)   # 释放Ctrl
```


### 资源回收问题
1. 视频资源加载是从编译好的py文件里读取的（rcc转换），视频是先加载到temp目录里面的才循环进行播放的，PyCharm的停止运行按钮就会无法回收资源导致temp文件夹产生没有的MP4文件占用硬盘资源。win+R输入%temp%直接到达缓存文件夹。
   1. 实际测试从 系统管理器 强制终止、 alt + F4 强制关闭窗口 或 界面卡死被退出视频资源还是回收了。
   2. 没有测试强制关机或断电会不会有问题。
   3. 尽管没有看到资源泄露的问题，但是针对PyCharm强制终止运行导致的资源泄露还是做一个额外的回收处理(重新运行和停止运行)
   4. 文件名：`python.jOTqQx.mp4` `python.kSzSRN.mp4` `python.lsHgYY.mp4` `python.qrYDAf.mp4` `python.RpBOqm.mp4`，都有规律，上个正则就OK了。
2. 因为密钥是托管给win平台，所以需要卸载或不适用密钥的时候需要使用代码去清除密钥



### 卸载流程
- 删除交给系统托管的密钥（施工完毕）
- 尝试删除temp目录的视频资源文件
- 删除本目录的所有文件
- 解除热键注册（还没施工）
除了第一点，其他都在施工

#### 密钥回收
**核心代码：**
```python
# 回收密钥(需要先判断密钥是否存在)
if keyring.get_password(自己去代码看):
    keyring.delete_password(自己去代码看)
```

#### 回收在temp的文件
对于用户而言，这里感觉其实是多余的担心。正常的使用确实不会照成泄露，只有开发者才会。但是即使如此我还是写了这个功能，主打一个不带痕迹的清除自己。

**高性能删除泄露的视频资源文件**
```python
def clear_temp():
    """删除残留在temp文件的MP4动态壁纸文件
    返回值：如果成功删除所有找到的缓存文件就返回True
    否则返回False（可能文件被正在使用或被添加了只读无法删除的权限等）
    """
    # 通过环境变量获取Windows临时文件夹路径
    temp_directory = os.environ.get("TEMP") or os.environ.get("TMP")

    # 构建匹配规则(python.6个字母.mp4),re.I为边界控制，使用后能从4.8ms变为2.9ms
    match_rule = re.compile(r"^python\.[a-zA-Z]{6}\.mp4$",re.I)

    # 遍历temp文件夹的所有符合匹配规则的文件，把符合的文件名构造成列表
    delete_files = [file_name for file_name in os.listdir(path=temp_directory) if re.search(match_rule, file_name)]

    flag = True # 成功卸载所有泄露文件的标志位
    # 开始删除泄露的文件
    for file_name in delete_files:  # 遍历需要删除的文件名
        try:
            # 文件绝对路径拼接后进行删除
            os.remove(os.path.join(temp_directory, file_name))
            info(f"成功删除:{file_name}")
        except(OSError,FileNotFoundError):
            exception("缓存文件(动态壁纸MP4文件)删除失败，以下是错误信息:\n")

    return True if flag else False
```
**使用过程中需要先销毁视频对象**，避免出出现视频正在被使用无法删除。
稳定释放正在使用视频资源的方案：
```python
# 回收在temp目录下的视频资源
# self.video_player.stop()                # 停止播放
# self.video_player.setVideoOutput(None)  # 断开视频输出
self.DynamicBackground.deleteLater()    # 删除播放的窗口
self.video_player.deleteLater()         # 删除视频播放对象
# self.video_player = None  # 清除视频播放对象的引用
# self.DynamicBackground = None  # 清除视频播放窗口对象的引用
```
核心代码：`self.video_player.deleteLater()`
直接把播放对象销毁就行，以下是播放代码（解析了`video_player`本质）
```python
# 动态壁纸
self.video_player = QMediaPlayer(self)  # 创建多媒体播放器
self.video_player.setVideoOutput(self.DynamicBackground)  # 多媒体播放器设置窗口来视频输出
self.video_player.setSource(QUrl("qrc:/背景/背景/动态视频.mp4"))  # 设置播放资源，fromLocalFile处理路径问题
self.DynamicBackground.setAspectRatioMode(Qt.AspectRatioMode.KeepAspectRatioByExpanding)  # 保持宽高比并填充整个控件
self.video_player.setLoops(QMediaPlayer.Loops.Infinite)  # 循环无限次数
self.video_player.play()  # 开始播放
```
**延迟回收泄露的MP4资源的代码：**
```python
# 延迟删除文件（确保资源完全释放）
QTimer.singleShot(1000, self.safe_clear_temp)  # 延迟1秒
```
### 状态检测界面
#### 状态输出
#### Q群绑定
添加Q群进行绑定时必要的参数
1. Q群名
2. 机器人名
3. 最高权限者
4. 退出指令的密码
5. 是否移除默认危险指令（默认否）

初始人设可以不填，不填就是没有人设。

Q群位置不填就是左上角（后期可以写一个算法进行自动匹配位置来进行优化）

QListWidget弄清删除顺序很重要，防止卡死。

##### Q群添加后列表刷新原理
1. 方案1
代价就是效能真的是非常低，但是在用户眼中也是感觉不到卡顿的。可以防止重复添加`# self.QQGroupList.addItem(self.QQGroupName.text())  # 把这个新添加的键值添加到列表里面去（重大bug就是会重复）`。这个最大的好处就是极大的节省了代码
```python
self.QQGroupList.clear()    # 清空列表
self.import_bind_data()     # 从配置文件里面重新加载数据到列表中
```
2. 方案2(当前使用方案，最求效能)
办到了筛选不重复的功能，及时跳出循环遍历避免无意义的遍历和添加选择项。
```python
before_add = self.config.bind.sections()    # 添加前的所有节
"""
一系列的修改操作
"""
# 把新的选择项添加进入Q群列表，可以确保不重复
for section in before_add:  # 遍历添加前的节看是否重复
    if section == self.QQGroupName.text():
        info(f"已修改绑定项:{section}")
        break   # 重复了退出循环
# 没有重复添加进去（重复的节不需要再次添加到列表里面去）
else:
    info(f"已成功添加绑定项:{self.QQGroupName.text()}")
    self.QQGroupList.addItem(self.QQGroupName.text())  # 把新的选择项目添加到列表中
# 保存Q群绑定的文件(无论是否重复都要)
self.config.save_bind_ini()
self.set_orign_tip()  # 输入框设置回正常的提示
```

## 笔记
将软件的启动到使用到终止视为一个函数计算过程。
我提供什么？（参数）
函数计算（隐藏细节）
我得到什么？（结果）

AI对接：deepseek，后面想搞 gemini(谷歌的，送挺多toekn的)

核心功能参数：
超管root(必要， 只能有一个)
退出指令的密码（必要，只有超管知道）
群聊名（必要）
危险功能移除（必要）
初始人设（非必要）
QQ窗口位置（非必要）

获得的东西
1. 群聊的聊天记录，放在硬盘。每次启动程序会进行覆盖上次记录。
2. 自动回复


## 后续按钮
1. 打开提示库，或修改提示库之类的
2. 关键词回复

## 输入重定向问题
- 进程池输出重定向
- 主程序输出重定向

逆天发现就是其logging输出都是红色是因为重定向为`sys.stderr`，只要改为`sys.stdout`输出的就全都是白色了。

记录成功代码
```python
sys.stdout = OutputRedirection()   # 实例化输出重定向
sys.stdout.text_print.connect(self.log_print)
def log_print(self, text):
    """日志输出
    text : 重定向返回的文本
    """
    self.ConsolePrint.insertPlainText(text)
# self.ConsolePrint.setText() 这个不行
```

```python
sys.stdout = self
    """事件重写"""
def write(self, text):
    self.ConsolePrint.insertPlainText(text)

def closeEvent(self, event):
    sys.stderr = None   # 错误输出重定向为空(之前是定向自己的)
    sys.stdout = None   # 输出重定向为空(之前是定向自己的)
    super().closeEvent(event)   # 继承之前的关闭功能
```


## 开发日志
没想我会以这种方式对自己之前的项目（QQ机器人）进行维护。权限隔离得重写，用户配置也得改，AIP发图得改，多媒体文本异常处理也得改，冗余逻辑代码得改。

### 输出重定向问题
我找了好多方法，但是总体来说我确实尝到了败果
1. 我成功用进程池实现了多窗口控制，但是PyQt6里面我却没有找到方法给他塞进去，GUI是主进程不能被阻塞（尝试过通过Qt线程来创建进程池，卡死失败）。
2. 只有在进程中才有独立的输出和接收的api，这也意味着只有进程能够实现输出重定向的方式
3. 无奈之中我用线程池实现了多窗口控制的效果，但是由于不是进程所以输出重定向的接口只有一个不能办到同时分流。

### PyQt6视频播放
https://blog.csdn.net/qq_24818607/article/details/145606820?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224f96bb934b7382ba7dcb23f5bf4b8e9b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=4f96bb934b7382ba7dcb23f5bf4b8e9b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-145606820-null-null.142^v102^pc_search_result_base6&utm_term=pyqt6%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8&spm=1018.2226.3001.4187


资源系统路径(:/path/to/resource)不能用于QUrl.fromLocalFile()，因为：
fromLocalFile() 只适用于本地文件系统路径
资源路径需要通过QUrl("qrc:/path/to/resource")格式加载
```python
def loop_dynamic_background(self, status):
    """循环主页窗口的动态背景循环"""
    from PyQt6.QtMultimedia import QMediaPlayer
    status_names = {
        QMediaPlayer.MediaStatus.NoMedia: "无媒体",
        QMediaPlayer.MediaStatus.LoadingMedia: "加载中",
        QMediaPlayer.MediaStatus.LoadedMedia: "已加载",
        QMediaPlayer.MediaStatus.StalledMedia: "停滞",
        QMediaPlayer.MediaStatus.BufferingMedia: "缓冲中",
        QMediaPlayer.MediaStatus.BufferedMedia: "已缓冲",
        QMediaPlayer.MediaStatus.EndOfMedia: "播放结束",
        QMediaPlayer.MediaStatus.InvalidMedia: "无效媒体"
    }
    print(f"媒体状态变化: {status_names.get(status, '未知状态')}")
    # 视频结束时重新播放
    if status == QMediaPlayer.MediaStatus.EndOfMedia:       # 如果视频播放结束
        self.video_player.setPosition(0)  # 回到开头
        self.video_player.play()  # 重新播放
```

我靠，使用链接的方式循环会给我黑一下屏，2个视频链接不上。不过没事，我给它多线程while一下就ok了，简单的写法就是循环int类型的上限，然后结束的时候给他链接一下信号。
AI:确实，使用 mediaStatusChanged 信号循环播放时会出现短暂黑屏，这是因为媒体播放器在循环过程中会经历"无媒体"状态。使用双播放器交替播放（推荐）,使用单个播放器预加载技术。`self.video_player_list = QMediaPlaylist()`创建循环列表用来处理(PyQt6已经移除)。双播放器交替就是高性能。
最终方案
```python
self.video_player.setLoops(QMediaPlayer.Loops.Infinite)  # 循环无限次数(本质是个-1)
```

有一个bug就是如果不设置播放窗口的外布局就会视频播放位置乱动，里面设不设置都没关系。父容器布局必须要有。

奇妙的是我在播放器的窗口`DynamicBackground`内放置了一个`Vertical Layout`控件就不用设置`layout = QVBoxLayout(self.DynamicBackground)`、`layout.setContentsMargins(0, 0, 0, 0)  # 无边框`、`layout.setSpacing(0)  # 无间距`的代码了，但是`setAspectRatioMode`的代码必须还得要，不然还是有bug
```python
# 确保父容器有布局
# 如果只是把动态视频加背景就必须加
layout = QVBoxLayout(self.DynamicBackground)
layout.setContentsMargins(0, 0, 0, 0)  # 无边框
layout.setSpacing(0)  # 无间距
self.video_player = QMediaPlayer(self)  # 创建多媒体播放器
self.player_widget = QVideoWidget(self.DynamicBackground)   # 传入ui的对应界面控件创建视频显示控件
self.DynamicBackground.layout().addWidget(self.player_widget)
self.video_player.setVideoOutput(self.player_widget)        # 多媒体播放器设置窗口来视频输出
self.video_player.setSource(QUrl("qrc:/背景/背景/动态视频.mp4"))  # 设置播放资源，fromLocalFile处理路径问题
self.player_widget.setAspectRatioMode(Qt.AspectRatioMode.IgnoreAspectRatio)     # 保持宽高比并填充整个控件
self.video_player.setLoops(2147483647)  # 循环极限次数
self.video_player.play()  # 开始播放
```

视频拉伸变化
```python
# IgnoreAspectRatio - 忽略宽高比
self.player_widget.setAspectRatioMode(Qt.AspectRatioMode.IgnoreAspectRatio)
# 效果：视频会拉伸以填满整个控件，不考虑原始宽高比
# 优点：完全填充控件
# 缺点：可能导致视频变形
# 适用场景：当控件比例与视频比例完全匹配时，或者变形不重要时

# KeepAspectRatio - 保持宽高比
self.player_widget.setAspectRatioMode(Qt.AspectRatioMode.KeepAspectRatio)
# 效果：保持视频原始宽高比，在控件内居中显示
# 优点：视频不变形
# 缺点：控件两侧或上下可能出现黑边
# 适用场景：需要保持视频原始比例的情况

#  KeepAspectRatioByExpanding - 保持宽高比并扩展
self.player_widget.setAspectRatioMode(Qt.AspectRatioMode.KeepAspectRatioByExpanding)
# 效果：保持视频原始宽高比，但会缩放视频直到填满整个控件
# 优点：无黑边，视频不变形
# 缺点：视频边缘可能被裁剪
# 适用场景：需要完全填充控件且不希望变形时
```

视频问题，我直接去提权了，这样搞方便很多，我直接提升窗口类型。
![alt text](image.png)
```python
self.video_player = QMediaPlayer(self)  # 创建多媒体播放器
self.video_player.setVideoOutput(self.DynamicBackground)        # 多媒体播放器设置窗口来视频输出
self.video_player.setSource(QUrl("qrc:/背景/背景/动态视频.mp4"))  # 设置播放资源，fromLocalFile处理路径问题
self.DynamicBackground.setAspectRatioMode(Qt.AspectRatioMode.KeepAspectRatioByExpanding)     # 保持宽高比并填充整个控件
self.video_player.setLoops(QMediaPlayer.Loops.Infinite)  # 循环无限次数
self.video_player.play()  # 开始播放
```
**尽力了**，确实没找到办法实现视频窗口上堆控件


### ***视频位置偏移问题***
正常播放视频后，视频位置发生了偏移，不在原来想要播放的窗口上了。我这里有bug就是需要手动改变窗口大小才能视频窗口才能恢复位置。
```python
self.adjustSize()       # 调整到推荐大小(这个非常有用)
def showEvent(self, event):
    """重写show方法处理视频位置异常"""
    super().showEvent(event)        # 继承父类的方法
    # self.adjustSize()       # 自动调整到推荐大小(这个非常有用，但是大小不受自己控制了)
    width, height = window.size().width(), window.size().height()
    self.resize(width, height + 1)      # 加1点像素
    self.resize(width, height)          # 恢复大小（通过改变边框的方法实现动态背景显示不完整的问题）
```

### 消息弹窗
https://c.biancheng.net/view/9421.html
```python
QMessageBox.question(
     parent,      # QWidget 实例
     title,       # 字符串
     text,        # 字符串
     buttons,     # StandardButton 组合
     defaultButton # StandardButton（可选）
)
```
information 消息对话框
critical    “操作错误”或“运行失败”
question    向用户提出问题并接收用户的答案

未来可能有用的东西
```python
# def messagebox(self, win_title, title, text, detailed_text, btn: list):
    #     """消息弹窗
    #     win_title : 窗口标题
    #     title : 自定义标题
    #     text ： 自定义的弹窗内容，支持HTML格式
    #     detailed_text : 详细内容
    #     btn : 数字列表，添加按钮1为保存，2为放弃，3为取消
    #     """
    #     # 创建自定义弹窗
    #     msg_box = QMessageBox()
    #     msg_box.setWindowTitle(win_title)               # win_title
    #     msg_box.setText(title)                          # 自定义标题
    #     msg_box.setInformativeText(text)                # 自定义的弹窗内容，支持HTML格式
    #     msg_box.setDetailedText(detailed_text)          # 详细内容
    #     msg_box.setIcon(QMessageBox.Icon.Information)   # 设置图标
    #
    #     # 添加自定义按钮
    #     if 1 in btn:
    #         save_btn = msg_box.addButton("保存", QMessageBox.ButtonRole.AcceptRole)
    #     if 2 in btn:
    #         discard_btn = msg_box.addButton("放弃", QMessageBox.ButtonRole.DestructiveRole)
    #     if 3 in btn:
    #         cancel_btn = msg_box.addButton("取消", QMessageBox.ButtonRole.RejectRole)
    #
    #     # 显示弹窗
    #     msg_box.exec()
    #
    #     # 处理结果
    #     if msg_box.clickedButton() == save_btn:
    #         self.statusBar().showMessage("用户选择了保存", 3000)
    #     elif msg_box.clickedButton() == discard_btn:
    #         self.statusBar().showMessage("用户选择了放弃", 3000)
    #     elif msg_box.clickedButton() == cancel_btn:
    #         self.statusBar().showMessage("用户取消了操作", 3000)

    # def error_msg_box(self):
    #     """弹窗错误窗口（仅通知错误）"""
    #     ok_button = msg_box.addButton(QMessageBox.StandardButton.Ok)  # 添加标准按钮
    #     ok_button.setText("确认")  # 将"OK"改为"确认"
    #
    #
    #
    #     msg_box.setDefaultButton(ok_button)     # 设置为默认
    #
```
QtDesigner方便开发
https://blog.csdn.net/weixin_45905286/article/details/149342955?spm=1011.2415.3001.5331

qdesigner_internal--StyleSheetEditor {
	font-size:30px;  /*字体大小, 根据需要自行更改*/
}


### 垂直滚动条
https://blog.csdn.net/chenyijun/article/details/133385962?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-133385962-blog-129893034.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-133385962-blog-129893034.235%5Ev43%5Epc_blog_bottom_relevance_base5
属性	意思
QScrollBar:vertical	垂直滚动条整体背景风格
QScrollBar::handle:vertical	垂直滚动条滑动块风格
QScrollBar::add-line:vertical	垂直滚动条底部添加一个按钮
QScrollBar::sub-line:vertical	垂直滚动条覆盖顶部的按钮
QScrollBar:up-arrow:vertical	垂直滚动条顶边按钮上的箭头
QScrollBar:down-arrow:vertical	垂直滚动条底部按钮上的箭头
QScrollBar::add-page:vertical	垂直滚动条滑动块下边区域的风格
QScrollBar::sub-page:vertical	垂直滚动条滑动块上边区域的风格


## 重写指令系统和权限系统
权限系统是针对于指令系统写的，指令系统中存在大部分的“危险指令”，如果被别人滥用就极可能违法违规和导致自己账号被别人举报封禁。

最主要和最担心的问题还是递归的问题，QQ机器人帐号能否自己向自己发出提问后不会产生递归？情况发生：
1. 检测到`@机器人名`之后进行回复，回复时是`@对方名 + 回复内容`，所以如果是自己的会就会导致`@对方名 + 回复内容 = @机器人名 + 回复内容`，由此形成一个死循环。
2. 关键词回复中把机器人账号名设置了为关键词，如果自己调用自己，当它回复后会@账号名，这就触发了关键词，下一次会有又有@，此时就变成了递归的死循环
之前的解决方案就是`@账号名`替换为`@自己`。





## 报废代码(以后可能有用)
```python
# self.QQGroupName.textEdited.connect(self.qq_group_name_edit)                    # Q群名称信号
# self.BotName.textEdited.connect(self.bot_name_edit)                             # 机器人名信号
# self.Root.textEdited.connect(self.root_edit)                                    # 最高权限者信号
# self.InitRole.textEdited.connect(self.init_role_edit)                           # 初始人设信号
# self.ExitPassword.textEdited.connect(self.exit_password_edit)                   # 退出密码信号
# self.RemoveDangerousOrder.toggled.connect(self.remove_dangerous_order_change)   # 移除危险指令信号

def qq_group_name_edit(self, text):
"""Q群名编辑框槽函数实现"""
print(text)

def bot_name_edit(self, text):
"""机器人名编辑框槽函数实现"""
print(text)

def root_edit(self, text):
"""最高权限者编辑框槽函数实现"""
print(text)

def exit_password_edit(self, text):
"""退出密码编辑框槽函数实现"""
print(text)

def init_role_edit(self, text):
"""初始人设编辑框槽函数实现"""
print(text)

def remove_dangerous_order_change(self, state: bool):
"""移除危险指令编辑框槽函数实现"""
print(state)
```

```python
    @staticmethod
    def store_api_key(service_name, username, password):
        """存储api密钥
        参数：
        service_name :   服务名
        username :   用户名
        password : 密钥
        """
        keyring.set_password(service_name, username, password)
        print("已将密钥存储完毕")
        return True

    @staticmethod
    def __get_api_key__(service_name, username):
        """私有方法读取密钥(静态方法)
        参数：
        service_name :   服务名
        username :   用户名
        """
        print(f"已获取的API密钥")  # 不打印输出密钥显示避免泄露
        return keyring.get_password(service_name, username)

    @staticmethod
    def remove_api_key(service_name, username):
        """删除存储的密钥(静态方法)
        参数：
        service_name :   服务名
        username :   用户名
        """
        keyring.delete_password(service_name, username)
        print("已从系统密钥库删除密钥")
        return True
```

消息截获和涩图发送
```python
def hook_message(self,message_dict,max_processing_queues=10):
    """设置需要截获的消息,可以是发送者，时间，发送消息的内容
    参数： message_dict ： 单条消息字典{"发送者": "yan di fei","发送消息": "hello world","发送时间": "10:10:20"}
    max_processing_queues : 默认10，最大处理队列，超过队列最大数就不进队了
    """
    if len(self.message_processing_queues) > max_processing_queues: # 超出最大处理数
        print(f"\033[91m超出消息最大处理数:{max_processing_queues}，不对消息进行处理\033[0m")  # 亮红色
        message_dict["发送者"], message_dict["发送消息"] = "系统", f"超出消息最大处理数:{max_processing_queues}，不对消息进行处理"
        self.message_processing_queues.append(message_dict)  # 加入消息处理队列
        """额外模块"""
    elif "每日涩图" in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 色图发送请求\033[0m")
        self.send_url_image("https://api.seaya.link/random?type=file")  # 发送图片
    elif "cos涩图" in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 色图发送请求\033[0m")
        self.send_url_image("http://api.yujn.cn/api/cos.php")  # 发送图片
    elif "少女涩图" in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 色图发送请求\033[0m")
        self.send_url_image("https://cdn.seovx.com/d/?mom=302")  # 发送图片
    elif "白丝涩图" in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 白丝色图发送请求\033[0m")
        self.send_url_image("https://v2.xxapi.cn/api/baisi?return=302")  # 发送白丝图片
    elif "黑丝涩图" in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 黑丝色图发送请求\033[0m")
        self.send_url_image("https://v2.xxapi.cn/api/heisi?return=302")  # 发送黑丝图片
    elif "萝莉涩图" in message_dict["发送消息"] in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 色图发送请求\033[0m")
        self.send_url_image("https://t.alcy.cc/moe")  # 发送图片
    # 精美壁纸
    elif "精美壁纸" in message_dict["发送消息"] in message_dict["发送消息"]:
        print(f"\033[94m收到 {message_dict["发送者"]} 精美壁纸发送请求\033[0m")
        self.send_url_image("https://image.anosu.top/pixiv")  # 发送图片
        """正规定模块"""
    # 截获自己被@的情况做出消息处理
    elif f"@{self.monitor_name}" in message_dict["发送消息"]:  # 最新列表获取消息
        if self.monitor_name == message_dict["发送者"]:        # 自己@自己
            message_dict["发送者"] = "自己"  # 给自己改名
        print(f"\033[94m我被{message_dict["发送者"]}艾特了，消息是:{message_dict["发送消息"]}\033[0m")
        self.message_processing_queues.append(message_dict)  # 加入消息处理队列
    # 检查是否开启了关键词自动回复,仅当开启了才会
    elif not self.keyword_respond or message_dict["发送者"] == self.monitor_name:  # 关键词触发需要3个条件：1.设置了关键词2.消息体存在关键词3.消息体的发送者不是自己
        return True   # 没有开启关键词自动回复直接退出
    # 检查是否为排除对象
    elif self.fiter_keyword_jude(message_dict["发送者"]):   # 正则判断是否为排除的发送者
        print(f"\033[95m排除对{message_dict["发送者"]}的消息处理\033[0m")  # 亮紫色
        return True   # 存在排除的发送者直接返回退出
    # 截获指定的消息（关键词）进行处理
    elif self.message_keyword_jude(message_dict["发送消息"]):   # 正则判断消息(如果发送者是自己就过滤关键词触发)
        print(f"\033[94m截获关键词消息:{message_dict["发送消息"]}，发送者是:{message_dict["发送者"]}\033[0m")
        self.message_processing_queues.append(message_dict)  # 加入消息处理队列
    # 截获指定发送者存在关键词的消息进行处理(发送者全名在字典你面，发送者的关键词在消息体里面)
    elif self.message_sender_keyword_jude(message_dict["发送者"], message_dict["发送消息"]):     # 正则判断发送者及其消息(如果发送者是自己就过滤关键词触发)
        print(f"\033[94m截获发送者:{message_dict["发送者"]}，消息是:{message_dict["发送消息"]}\033[0m")
        self.message_processing_queues.append(message_dict)  # 加入消息处理队列
    # 截获指定的发送者进行处理
    elif self.sender_keyword_jude(message_dict["发送者"]):     # 正则判断发送者(如果发送者是自己就过滤关键词触发)
        print(f"\033[94m截获关键发送者:{message_dict["发送者"]}，发送消息是:{message_dict["发送消息"]}\033[0m")
        self.message_processing_queues.append(message_dict)  # 加入消息处理队列
    return True
```

消息发送，后台文本粘贴和发送
```python
# 激活窗口到前台
win32gui.SetForegroundWindow(self.qq_chat_hwnd)
# 激活窗口
win32gui.SendMessage(self.qq_chat_hwnd, win32con.WM_SETFOCUS, 0, 0)

# 设置焦点
self.edit_box.SetFocus()
self.text_control.SetFocus()
# 先发送 WM_ACTIVATE 激活窗口再发送 WA_CLICKACTIVE 鼠标激活
win32api.SendMessage(self.qq_chat_hwnd, win32con.WM_ACTIVATE, win32con.WA_CLICKACTIVE,0)
```

高速post后台发送，比`keybd_event`和`SendMessage`速度快
特性	PostMessage方法	keybd_event方法
执行机制	直接向窗口消息队列发送消息	调用系统级键盘事件API
系统开销	低（直接窗口通信）	中（经过系统事件队列）
目标精确度	高（直接指定窗口句柄）	中（依赖当前焦点窗口）
可靠性	中（依赖窗口消息处理）	高（模拟真实键盘事件）
后台操作	支持（不要求窗口激活）	需要窗口激活或在前台
兼容性	中（部分应用可能忽略消息）	高（系统级模拟）
```python
# """直接向控件发送粘贴消息"""
# win32api.SendMessage(self.qq_chat_hwnd, win32con.WM_PASTE, 0, 0)

# 对于复杂控件
# win32gui.SendMessage(self.qq_chat_hwnd, win32con.EM_REPLACESEL, True, "我是一个热")

# 方案1: 设置整个文本内容
# win32gui.SendMessage(self.qq_chat_hwnd, win32con.WM_SETTEXT, 0, "直接注入的文本内容")

# 方案2: 在插入点插入文本(模拟粘贴行为)
# 替换当前选中内容(如果有)
# win32gui.SendMessage(self.qq_chat_hwnd, win32con.EM_REPLACESEL, True, text)
```
失败
```python
# 直接发送粘贴消息
win32gui.SendMessage(hwnd, win32con.WM_PASTE, 0, 0)
# 发送WM_PASTE消息
win32gui.PostMessage(hwnd, win32con.WM_PASTE, 0, 0)
# 发送WM_COMMAND
win32gui.PostMessage(hwnd, win32con.WM_COMMAND, win32con.ID_EDIT_PASTE, 0)
```

高性能失败

```python
"""后台模拟Ctrl+V按键"""
# 获取扫描码 (使用MapVirtualKey的推荐方式)
ctrl_scan_code = win32api.MapVirtualKey(win32con.VK_CONTROL, 0)
v_scan_code = win32api.MapVirtualKey(ord('V'), 0)  # 注意使用大写V
# 构建lParam参数
ctrl_down = (1 << 24) | (ctrl_scan_code << 16) | 1
ctrl_up = (1 << 24) | (ctrl_scan_code << 16) | (0xC0 << 24) | 1
v_down = (1 << 24) | (v_scan_code << 16) | 1
v_up = (1 << 24) | (v_scan_code << 16) | (0xC0 << 24) | 1
# 按下Ctrl键->按下V键->释放V键->释放Ctrl键
win32api.PostMessage(self.hwnd, win32con.WM_KEYDOWN, win32con.VK_CONTROL, ctrl_down)
win32api.PostMessage(self.hwnd, win32con.WM_KEYDOWN, ord('V'), v_down)  # 大写V
win32api.PostMessage(self.hwnd, win32con.WM_KEYUP, ord('V'), v_up)
win32api.PostMessage(self.hwnd, win32con.WM_KEYUP, win32con.VK_CONTROL, ctrl_up)
```

文件复制到剪切板
```python
# 复制pdf到剪切板逻辑
# 构造文件列表字符串（双NULL结尾的Unicode）
file_list = rf".\用户设置\option\{jm_album_id}.pdf" + "\0\0"  # 单个文件也需双NULL结尾
# 获取文件拖放格式ID
file_drop_format = win32clipboard.RegisterClipboardFormat("FileDrop")
# 转为UTF-16小端字节
file_list_bytes = file_list.encode("utf-16le")
# 构造DROPFILES头部 (20字节)
dropfiles_header = struct.pack(
    "iiiii",
    20,  # pFiles: 文件列表偏移量(20字节后开始)
    0, 0,  # pt: 鼠标位置(设为0)
    0,  # fNC: 非客户区标识(设为0)
    1  # fWide: Unicode标志(必须为1)
)
# 合并头部和文件数据
clip_data = dropfiles_header + file_list_bytes
try:
    win32clipboard.OpenClipboard()   # 打开剪切板
    win32clipboard.EmptyClipboard()  # 清空剪切板

    # 分配全局内存(内存分配和复制操作仍然是必不可少的核心步骤)
    h_global = ctypes.windll.kernel32.GlobalAlloc(win32con.GMEM_MOVEABLE, len(clip_data))
    ctypes.memmove(ctypes.c_void_p(h_global), clip_data, len(clip_data))

    # 设置两种格式增强兼容性
    win32clipboard.SetClipboardData(win32con.CF_HDROP, file_list_bytes)  # 

    win32clipboard.SetClipboardData(win32con.CF_HDROP, h_global)

except Exception as e:
    print(f"复制文件到剪贴板失败: {str(e)}")
finally:
    win32clipboard.CloseClipboard() # 关闭剪切板
```


## 后续改进
把这两个信号给改进才行，虽然实现了功能，但是在鼠标点击选择不同的选择项时会进行2遍历读取。
```python
self.QQGroupList.currentItemChanged.connect(self.show_qq_group_info)    # QQ群列表选择项发生改变时显示Q群信息
self.QQGroupList.clicked.connect(self.show_qq_group_info2)              # QQ群列表选择项被点击时显示Q群信息
```
